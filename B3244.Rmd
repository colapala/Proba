---
title: "TP de Probabilités"
author: "Chanèle Jourdan, Corentin Laharotte, Jorje Terreu"
date: "12/05/2019"
output:
  html_document:
    df_print: paged
  pdf_document: default
---


  Ce Tp a pour but de créer des générateurs pseudo-aléatoires et de leur faire passer des tests statistiques afin de comparer la qualité des séquences produites.


#Partie 1 : Test de générateurs pseudo-aléatoires

```{r setup, include=FALSE}
library(randtoolbox)
source('generateurs.R')
source('fonctions.R')

sVN <- 2504
sMT <- 2504
graine <- sample.int(1000,1)
Nsimu <- 1000
Nrepet <- 1
```

###Question 1:

Les generateurs a congruence lineaire consiste a appliquer une transformation lineaire suivie d'une operation de congruence : 
$S=U=\{0,...,m-1\}, S_{n}=f(S_ {n-1})=a*S_ {n-1}+b\mod \ m, X_{n}=g(S_{n})=S_{n}$

Nous avons implemente 2 générateurs a congruence lineaire:
  *Un generateur a congruence linéaire RANDU : a=65539, b=0, $m=2^{31}$
  *Un generateur a congruence linéaire Standard Minimal : a=16807, b=0,$m=2^{31}-1$

###Question 2.1 Test Visuel:

Nous allons comparer ces generateurs pour une suite de 1000 valeurs. 

```{r, include=FALSE}
vn <- VonNeumann(Nsimu,Nrepet,sVN)
mt <- MersenneTwister(Nsimu,Nrepet,sMT)
rd<-RANDU(Nsimu,graine)
sm<-StandardMinimal(Nsimu,graine)
```
```{r}
par(mfrow=c(1,2))
hist(mt[,1],xlab='',main='Mersenne Twister')
hist(vn[,1],xlab='',main='Von Neumann')
hist(rd[,1],xlab='',main='RANDU')
hist(sm[,1],xlab='',main='Standard Minimal')
```

Nous pouvons remarquer que pour 1000 valeurs ...

###Question 2.2:

Nous pouvons nous interesser a la repartition des valeurs obtenues en fonction de la valeur precedente. 
```{r}
par(mfrow=c(1,2))
plot(mt[1:(Nsimu-1),1],mt[2:Nsimu,1],xlab='MT(i)', ylab='MT(i+1)', main='Mersenne Twister')
plot(vn[1:(Nsimu-1),1],vn[2:Nsimu,1],xlab='VN(i)', ylab='VN(i+1)', main='Von Neumann')
plot(rd[1:(Nsimu-1),1],rd[2:Nsimu,1],xlab='RD(i)', ylab='RD(i+1)', main='RANDU')
plot(sm[1:(Nsimu-1),1],sm[2:Nsimu,1],xlab='RD(i)', ylab='RD(i+1)', main='Standard Minimal')
```

Nous pouvons voir que les valeurs obtenues sont reparties assez uniformement, il n'y a pas de reel lien entre la valeur obtenue et la valeur precedente.

###Question 3 Test de fréquence monobit:

On s'interesse au nombre de 0 et de 1 dans les bits d'une sequence entiere. On teste si les nombres de 1 et de 0 d'une sequence sont approximativement les memes, comme attendu dans une sequence vraiment aleatoire.

explications----

les $p_{valeur}$ des différents algorithmes sont:

Mersenne Twister | Von Neumann | RANDU | Standard Minimal

results------- $p_{valeur}$=
```{r}
pvaleurmtF<-Frequency(mt,32)
pvaleurmtF
pvaleursmF<-Frequency(sm,31)
pvaleursmF
pvaleurvnF<-Frequency(vn,12)#ou 12? 
pvaleurvnF
pvaleurrdF<-Frequency(rd,31)
pvaleurrdF
```

interprétation: si la $p_{valeur}$ est inferieure a 0.01 alors la sequence n'est pas aleatoire. Sinon, on ne peut pas conclure.

###Question 4 Test des runs:

On s'interesse maintenant a la longueur des suites successives de 0 et de 1 dans la sequence observee. 

explications----

les $p_{valeur}$ des differents algorithmes sont:

Mersenne Twister | Von Neumann | RANDU | Standard Minimal

results------- $p_{valeur}$=
```{r}
pvaleurmtR<-Runs(mt,31)
pvaleurmtR
pvaleursmR<-Runs(sm,31)
pvaleursmR
pvaleurvnR<-Runs(vn,12)#ou 12?
pvaleurvnR
pvaleurrdR<-Runs(rd,31)
pvaleurrdR
```


interpretation: si la $p_{valeur}$ est inferieure a 0.01 alors la sequence n'est pas aleatoire. Sinon, on ne peut pas conclure.

###Question 5 Test d'ordre:

explications----

les $p_{valeur}$ des différents algorithmes sont:

Mersenne Twister | Von Neumann | RANDU | Standard Minimal

results------- $p_{valeur}$=

```{r}
pvaleurmtO<-Ordre(mt,Nsimu)
pvaleurmtO
pvaleursmO<-Ordre(sm,Nsimu)
pvaleursmO
pvaleurvnO<-Ordre(vn,Nsimu)
pvaleurvnO
pvaleurrdO<-Ordre(rd,Nsimu)
pvaleurrdO
```


interpretation: si la $p_{valeur}$ est inferieure a 0.01 alors la sequence n'est pas aleatoire. Sinon, on ne peut pas conclure.


#Partie 2 : Application aux files d'attentes


##Files M/M/1

###Question 6:


```{r, include=FALSE}
lambda<-0.1
mu<-0.1
D<-125

result1<-FileMM1(lamba,mu,D)
depart<-result1[[1]]
arrivee<-result1[[2]]

#affichage console pour débugger (à enlever)
print("arrivee")
for(i in 1:length(depart)){
  print(depart[[i]])
}

print("depart")
for(i in 1:length(depart)){
  print(arrivee[[i]])
}
```


###Question 7 et 8:

```{r, include=FALSE}
result2<-FileMM1Version2(arrivee,depart)
temps<-result2[[1]]
client<-result2[[2]]
attenteMoyenne<-result2[[3]]
nbClientMoyen<-result2[[4]]
```

###Application:
```{r}
#A faire
```


##Files M/M/n

###Question bonus









##Quelques plus pour la mise en forme

Il est possible de mettre des mots *en italique* ou **en gras**.
On peut également faire des listes :

* Item 1 

* Item 2 

    + sub-item 1 

    + sub-item 2 

Et des tableaux :

Permière colonne | Deuxième colonne 
------------- | ------------- 
a    | x        
b        | y        

Ou mettre des formules : $Aire = \pi\,r^{2}$.

###Remarque

