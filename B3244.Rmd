---
title: "TP de ProbabilitÃfÂ©s"
author: "ChanÃfÂ¨le Jourdan, Corentin Laharotte, Jorje Terreu"
date: "12/05/2019"
output:
  html_document:
    df_print: paged
  pdf_document: default
---



  Ce Tp a pour but de crÃ©er des gÃ©nÃ©rateurs pseudo-alÃ©atoires et de leur faire passer des tests statistiques afin de comparer la qualitÃ© des sÃ©quences produites.


#Partie 1.

```{r setup, include=FALSE}
library(randtoolbox)
source('generateurs.R')
source('fonctions.R')

sVN <- 2504
sMT <- 2504
graine <- sample.int(1000,1)
Nsimu <- 1000
Nrepet <- 1
```

##Question 1

Les generateurs a congruence lineaire consiste a appliquer une transformation lineaire suivie d'une operation de congruence : 
$S=U=\{0,...,m-1\}, S_{n}=f(S_ {n-1})=a*S_ {n-1}+b\mod \ m, X_{n}=g(S_{n})=S_{n}$

Nous avons implemente 2 gÃ©nÃ©rateurs a congruence lineaire:
  *Un generateur a congruence linÃ©aire RANDU : a=65539, b=0, $m=2^{31}$
  *Un generateur a congruence linÃ©aire Standard Minimal : a=16807, b=0,$m=2^{31}-1$

##Question 2.1 Test Visuel

Nous allons comparer ces generateurs pour une suite de 1000 valeurs. 

```{r, include=FALSE}
vn <- VonNeumann(Nsimu,Nrepet,sVN)
mt <- MersenneTwister(Nsimu,Nrepet,sMT)
rd<-RANDU(Nsimu,graine)
sm<-StandardMinimal(Nsimu,graine)
```
```{r}
par(mfrow=c(1,2))
hist(mt[,1],xlab='',main='Mersenne Twister')
hist(vn[,1],xlab='',main='Von Neumann')
hist(rd[,1],xlab='',main='RANDU')
hist(sm[,1],xlab='',main='Standard Minimal')
```

Nous pouvons remarquer que pour 1000 valeurs ...

##Question 2.2

Nous pouvons nous interesser a la repartition des valeurs obtenues en fonction de la valeur precedente. 
```{r}
par(mfrow=c(1,2))
plot(mt[1:(Nsimu-1),1],mt[2:Nsimu,1],xlab='MT(i)', ylab='MT(i+1)', main='Mersenne Twister')
plot(vn[1:(Nsimu-1),1],vn[2:Nsimu,1],xlab='VN(i)', ylab='VN(i+1)', main='Von Neumann')
plot(rd[1:(Nsimu-1),1],rd[2:Nsimu,1],xlab='RD(i)', ylab='RD(i+1)', main='RANDU')
plot(sm[1:(Nsimu-1),1],sm[2:Nsimu,1],xlab='RD(i)', ylab='RD(i+1)', main='Standard Minimal')
```

Nous pouvons voir que les valeurs obtenues sont reparties assez uniformement, il n'y a pas de reel lien entre la valeur obtenue et la valeur precedente.

##Question 3 Test de frÃ©quence monobit

On s'interesse au nombre de 0 et de 1 dans les bits d'une sequence entiere. On teste si les nombres de 1 et de 0 d'une sequence sont approximativement les memes, comme attendu dans une sequence vraiment aleatoire.

explications----

les $p_{valeur}$ des diffÃ©rents algorithmes sont:

Mersenne Twister | Von Neumann | RANDU | Standard Minimal

results------- $p_{valeur}$=
```{r}
pvaleurmtF<-Frequency(mt,32)
pvaleurmtF
pvaleursmF<-Frequency(sm,31)
pvaleursmF
pvaleurvnF<-Frequency(vn,12)#ou 12? 
pvaleurvnF
pvaleurrdF<-Frequency(rd,31)
pvaleurrdF
```

interprÃ©tation: si la $p_{valeur}$ est inferieure a 0.01 alors la sequence n'est pas aleatoire. Sinon, on ne peut pas conclure.

##Question 4 Test des runs

On s'interesse maintenant a la longueur des suites successives de 0 et de 1 dans la sequence observee. 

explications----

les $p_{valeur}$ des differents algorithmes sont:

Mersenne Twister | Von Neumann | RANDU | Standard Minimal

results------- $p_{valeur}$=
```{r}
pvaleurmtR<-Runs(mt,31)
pvaleurmtR
pvaleursmR<-Runs(sm,31)
pvaleursmR
pvaleurvnR<-Runs(vn,12)#ou 12?
pvaleurvnR
pvaleurrdR<-Runs(rd,31)
pvaleurrdR
```


interpretation: si la $p_{valeur}$ est inferieure a 0.01 alors la sequence n'est pas aleatoire. Sinon, on ne peut pas conclure.

##Question 5 Test d'ordre

explications----

les $p_{valeur}$ des diffÃ©rents algorithmes sont:

Mersenne Twister | Von Neumann | RANDU | Standard Minimal

results------- $p_{valeur}$=

```{r}
pvaleurmtO<-Ordre(mt,Nsimu)
pvaleurmtO
pvaleursmO<-Ordre(sm,Nsimu)
pvaleursmO
pvaleurvnO<-Ordre(vn,Nsimu)
pvaleurvnO
pvaleurrdO<-Ordre(rd,Nsimu)
pvaleurrdO
```


interpretation: si la $p_{valeur}$ est inferieure a 0.01 alors la sequence n'est pas aleatoire. Sinon, on ne peut pas conclure.


##Quelques plus pour la mise en forme

Il est possible de mettre des mots *en italique* ou **en gras**.
On peut Ã©galement faire des listes :

* Item 1 

* Item 2 

    + sub-item 1 

    + sub-item 2 

Et des tableaux :

PermiÃ¨re colonne | DeuxiÃ¨me colonne 
------------- | ------------- 
a    | x        
b        | y        

Ou mettre des formules : $Aire = \pi\,r^{2}$.

###Remarque
Rmarkdown fait gagner du temps pour les compte-rendus et permet d'intÃ©grer plus facilement des parties de code quand on le souhaite. Toutefois, je vous conseille d'avoir un fichier .R dans lequel vous ne mettez que du code et d'intÃ©grer celui-ci dans le .Rmd lorsque vous obtenez des rÃ©sultats. Faites les commentaires au fur et Ã  mesure et n'attendez pas la derniÃ¨re heure !
