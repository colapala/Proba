---
title: "TP de Probabilit?s"
author: "Chan?le Jourdan, Corentin Laharotte, Jorje Terreu"
date: "12/05/2019"
output:
  html_document:
    df_print: paged
  pdf_document: default
---


  Ce Tp a pour but de cr?er des g?n?rateurs pseudo-al?atoires et de leur faire passer des tests statistiques afin de comparer la qualit? des s?quences produites.


#Partie 1 : Test de g?n?rateurs pseudo-al?atoires

```{r setup, include=FALSE}
library(randtoolbox)
source('generateurs.R')
source('fonctions.R')

graine <- sample.int(1000,1)
Nsimu <- 1000
Nrepet <- 1
```

###Question 1:

Les generateurs a congruence lineaire consiste a appliquer une transformation lineaire suivie d'une operation de congruence : 
$S=U=\{0,...,m-1\}, S_{n}=f(S_ {n-1})=a*S_ {n-1}+b\mod \ m, X_{n}=g(S_{n})=S_{n}$

Nous avons implemente 2 g?n?rateurs a congruence lineaire:
  * Un generateur a congruence lin?aire RANDU : a=65539, b=0, $m=2^{31}$
  * Un generateur a congruence lin?aire Standard Minimal : a=16807, b=0,$m=2^{31}-1$

###Question 2.1 Test Visuel:

Nous allons comparer ces generateurs pour une suite de 1000 valeurs. Pour cela nous générons une graine aléatoire avec un nombre compris entre 1000 et 1. 

```{r, include=FALSE}
vn <- VonNeumann(Nsimu,Nrepet,graine)
mt <- MersenneTwister(Nsimu,Nrepet,graine)
rd<-RANDU(Nsimu,graine)
sm<-StandardMinimal(Nsimu,graine)
```
```{r}
par(mfrow=c(1,2))
hist(mt[,1],xlab='',main='Mersenne Twister')
hist(vn[,1],xlab='',main='Von Neumann')
hist(rd[,1],xlab='',main='RANDU')
hist(sm[,1],xlab='',main='Standard Minimal')
```

  Nous pouvons remarquer que pour 1000 valeurs, les répartitions des résultats obtenus grâce aux générateurs Mersenne Twister, RANDU et Standard minimal sont globalement uniformes. Même si les histogrammes obtenus ne sont pas lisses, les répartitions sont visuellement assez satisfaisantes pour être considérées comme uniformes.
En augmentant le nombre de valeurs généré, les histogrammes obtenus tendent à se lisser. 
  Seul le générateur de Von Neumann n'est visuellemnt pas satisfaisant, en effet, la majorité des valeurs sont regroupées dans l'intervalle [0,2000]. La répartition ne semble donc pas uniforme. 

###Question 2.2:

Nous pouvons nous interesser a la repartition des valeurs obtenues en fonction de la valeur precedente: 
```{r}
par(mfrow=c(1,2))
plot(mt[1:(Nsimu-1),1],mt[2:Nsimu,1],xlab='MT(i)', ylab='MT(i+1)', main='Mersenne Twister')
plot(vn[1:(Nsimu-1),1],vn[2:Nsimu,1],xlab='VN(i)', ylab='VN(i+1)', main='Von Neumann')
plot(rd[1:(Nsimu-1),1],rd[2:Nsimu,1],xlab='RD(i)', ylab='RD(i+1)', main='RANDU')
plot(sm[1:(Nsimu-1),1],sm[2:Nsimu,1],xlab='SM(i)', ylab='SM(i+1)', main='Standard Minimal')
```

 Nous pouvons voir que, sauf pour le générateur de Von Neumann, les valeurs obtenues sont reparties assez uniformement, il n'y a pas de reel lien entre la valeur obtenue et la valeur precedente. On ne peut pas prédire la valeur obtenue à l'intant $t$ en connaissant la valeur obtenue à l'instant $t-1$. 

###Question 3 Test de fr?quence monobit:

On s'interesse au nombre de 0 et de 1 dans les bits d'une sequence entiere. On teste si les nombres de 1 et de 0 d'une sequence sont approximativement les memes, comme attendu dans une sequence vraiment aleatoire.

Pour cela, on attribut aux 1 de notre séquence de bits la valeur 1, et aux 0 la valeur -1. Puis nous sommons les valeurs des bits de notre séquence. Et nous divison s le tout par le nombre de bits à considérer.
On obtient donc :$S_{obs}=\frac{|S_n|}{\sqrt(n)}$

Puis on regarde la valeur (appelée $p_{valeur}$) de la fonction de répartition de la loi $N(0,1)$ pour la valeur $S_{obs}$ obtenue. Si $p_{valeur}$ est petite, cela signifie qu'il est peu probable d'avoir obtenu la séquence générée, donc que la séquence n'est pas aléatoire.

les $p_{valeur}$ des diff?rents générateurs sont:

```{r, include=FALSE}
pvaleurmtF<-Frequency(mt,32)
pvaleursmF<-Frequency(sm,31)
pvaleurvnF<-Frequency(vn,13)
pvaleurrdF<-Frequency(rd,31)
```
```{r}
cat("Mersenne Twister | Von Neumann | RANDU | Standard Minimal\n",pvaleurmtF," | ",pvaleurvnF," | ",pvaleurrdF," | ",pvaleursmF)
```
 
  Nous pouvons remarquer que la $p_{valeur}$ du générateur de Von Neumann est inferieure a 0.01, donc la sequence  obtenue n'est pas aleatoire. 
  Pour les générateurs Mersenne Twister, RANDU et Standard Minimal, les $p_{valeur}$ obtenues sont supérieures à 0.01, nous ne pouvons donc rien conclure sur l'aspect aléatoire de la séquence obtenue.

###Question 4 Test des runs:

On s'interesse maintenant a la longueur des suites successives de 0 et de 1 dans la sequence obtenue. 
Avec un raisonnement assez similaire à la question précédente, on essaye de savoir s'il est probable d'obtenir une séquence avec cette même longueur de suites successives de 0 et de 1. Plus la $p_{valeur}$ obtenue est petite, moins il est probable d'obtenir la séquence observée, donc la séquence obtenue n'est pas aléatoire.

les $p_{valeur}$ des differents algorithmes sont:

```{r, include=FALSE}
pvaleurmtR<-Runs(mt,31)
pvaleursmR<-Runs(sm,31)
pvaleurvnR<-Runs(vn,13)
pvaleurrdR<-Runs(rd,31)
```
```{r}
cat("Mersenne Twister | Von Neumann | RANDU | Standard Minimal\n",pvaleurmtR," | ",pvaleurvnR," | ",pvaleurrdR," | ",pvaleursmR)
```

 Nous pouvons remarquer que les $p_{valeur}$ des générateurs de Von Neumann et de RANDU sont inferieures a 0.01, donc les sequences  obtenues ne sont pas aleatoires. 
  Pour les générateurs Mersenne Twister et Standard Minimal, les $p_{valeur}$ obtenues sont supérieures à 0.01, nous ne pouvons donc rien conclure sur l'aspect aléatoire de la séquence obtenue.

###Question 5 Test d'ordre:
  On s'intéresse maintenant à la suite de nombres obtenus.on veut compter le nombre d'apparition d'un ordre de séquence donné (exemple : le nombre de fois où le premier nombre obtenu est inférieur au deuxième pour une séquence de 2 nombres (exemple simpliste)).
Ce test d'ordre retourne une $p_{valeur}$.

les $p_{valeur}$ des différents algorithmes sont:

```{r, include=FALSE}
pvaleurmtO<-Ordre(mt,Nsimu)
pvaleursmO<-Ordre(sm,Nsimu)
pvaleurvnO<-Ordre(vn,Nsimu)
pvaleurrdO<-Ordre(rd,Nsimu)
```
```{r}
cat("Mersenne Twister | Von Neumann | RANDU | Standard Minimal\n",pvaleurmtO," | ",pvaleurvnO," | ",pvaleurrdO," | ",pvaleursmO)
```

 Nous pouvons remarquer que la $p_{valeur}$ du générateur de Von Neumann est inferieure a 0.01, donc la sequence  obtenue n'est pas aleatoire.
  Pour les générateurs Mersenne Twister, RANDU et Standard Minimal, les $p_{valeur}$ obtenues sont supérieures à 0.01, nous ne pouvons donc rien conclure sur l'aspect aléatoire de la séquence obtenue.


Nous pouvons remarquer que, suivant le Test choisi, les séquences de nombres rejetés ne sont pas issues des mêmes générateurs.Il est donc nécessaire de faire plusieurs tests différents pour "s'assurer" de l'aspect aléatoire d'une séquence (en réalité on peut seulement s'assurer du non-rejet de la séquence, nous ne pouvons pas confirmer l'aspect aléatoire de la séquence).

#Partie 2 : Application aux files d'attentes

 Nous souhaiterions réaliser des files d'attentes de Type FCFS(First Come First Served).

##Files M/M/1

  Pour un serveur particulier, il y a lambda arrivées et mu départs par unités de temps.

###Question 6 et 7:

  Nous aimerions connaître l'évolution de la file d'attente, c'est à dire, savoir combien il y a de clients dans la file d'attente à un instant donné.
  
  Pour ce premier exemple nous fixons les paramètres: 
  lambda=8
  mu=15
  D=12
  
```{r, include=FALSE}
lambda<-8
mu<-15
D<-12

result1<-FileMM1(lambda,mu,D)
depart<-result1[[1]]
arrivee<-result1[[2]]

result2<-FileMM1Version2(arrivee,depart)
temps<-result2[[1]]
client<-result2[[2]]

```
```{r}
plot(unlist(temps),unlist(client),xlab='temps', ylab='nbClients En Attente', main='M/M/1')
```

 Pour cet exemple nous fixons les paramètres: 
  lambda=14
  mu=15
  D=12
  
```{r, include=FALSE}
lambda<-14
mu<-15
D<-12

result1<-FileMM1(lambda,mu,D)
depart<-result1[[1]]
arrivee<-result1[[2]]

result2<-FileMM1Version2(arrivee,depart)
temps<-result2[[1]]
client<-result2[[2]]

```
```{r}
plot(unlist(temps),unlist(client),xlab='temps', ylab='nbClients En Attente', main='M/M/1')
```

 Pour cet exemple nous fixons les paramètres: 
  lambda=15
  mu=15
  D=12
  
```{r, include=FALSE}
lambda<-15
mu<-15
D<-12

result1<-FileMM1(lambda,mu,D)
depart<-result1[[1]]
arrivee<-result1[[2]]

result2<-FileMM1Version2(arrivee,depart)
temps<-result2[[1]]
client<-result2[[2]]

```
```{r}
plot(unlist(temps),unlist(client),xlab='temps', ylab='nbClients En Attente', main='M/M/1')
```

 Pour cet exemple nous fixons les paramètres: 
  lambda=20
  mu=15
  D=12
  
```{r, include=FALSE}
lambda<-20
mu<-15
D<-12

result1<-FileMM1(lambda,mu,D)
depart<-result1[[1]]
arrivee<-result1[[2]]

result2<-FileMM1Version2(arrivee,depart)
temps<-result2[[1]]
client<-result2[[2]]

```
```{r}
plot(unlist(temps),unlist(client),xlab='temps', ylab='nbClients En Attente', main='M/M/1')
```

  Nous pouvons remarquer que pour un même nombre de départ, plus le nombre d'arrivées par heures augmente, plus le réseau a tendance à se saturer.

###Question 8:

On calcule désormais le nombre moyen de clients dans le système et le temps de présence d'un client dans le système après 12 heures de fonctionnement.

  Pour ce premier exemple nous fixons les paramètres: 
  lambda=8
  mu=15
  D=12
  
```{r, include=FALSE}
lambda<-8
mu<-15
D<-12

result1<-FileMM1(lambda,mu,D)
depart<-result1[[1]]
arrivee<-result1[[2]]

result2<-FileMM1Version2(arrivee,depart)
attenteMoyenne<-result2[[3]]
nbClientMoyen<-result2[[4]]

```

```{r}
cat("attente moyenne :",attenteMoyenne)
cat("nombre moyen de clients :",nbClientMoyen)
```

 Pour cet exemple nous fixons les paramètres: 
  lambda=14
  mu=15
  D=12

```{r, include=FALSE}
lambda<-14
mu<-15
D<-12

result1<-FileMM1(lambda,mu,D)
depart<-result1[[1]]
arrivee<-result1[[2]]

result2<-FileMM1Version2(arrivee,depart)
attenteMoyenne<-result2[[3]]
nbClientMoyen<-result2[[4]]

```

```{r}
cat("attente moyenne :",attenteMoyenne)
cat("nombre moyen de clients :",nbClientMoyen)
```

 Pour cet exemple nous fixons les paramètres: 
  lambda=15
  mu=15
  D=12

```{r, include=FALSE}
lambda<-15
mu<-15
D<-12

result1<-FileMM1(lambda,mu,D)
depart<-result1[[1]]
arrivee<-result1[[2]]

result2<-FileMM1Version2(arrivee,depart)
attenteMoyenne<-result2[[3]]
nbClientMoyen<-result2[[4]]

```

```{r}
cat("attente moyenne :",attenteMoyenne)
cat("nombre moyen de clients :",nbClientMoyen)
```

 Pour cet exemple nous fixons les paramètres: 
  lambda=20
  mu=15
  D=12

```{r, include=FALSE}
lambda<-20
mu<-15
D<-12

result1<-FileMM1(lambda,mu,D)
depart<-result1[[1]]
arrivee<-result1[[2]]

result2<-FileMM1Version2(arrivee,depart)
attenteMoyenne<-result2[[3]]
nbClientMoyen<-result2[[4]]

```

```{r}
cat("attente moyenne :",attenteMoyenne)
cat("nombre moyen de clients :",nbClientMoyen)
```

  Nous pouvons constater qu'à partir du moment où il y a plus d'arrivée que de départ, le système tend à se saturer.

##Files M/M/n

###Question bonus

